# Crates

When you start your project, the very first thing you will likely do is create
a new crate. A crate is the unit in which Rust organizes code. You can think of
it it like a Ruby gem, a Python package, or a Node module.

A crate is also a compilation unit: unlike C or C++, which compile individual
files, in Rust an entire crate is always compiled in one go. This means you don't
have to worry about the ordering of includes, and it means that all definitions
are always visible.

## Contents

- graph: library in center, metadata in centre, binaries linking to library

### Metadata

Every crate contains some metadata, in the `Cargo.toml` file. This contains everything
cargo needs to know to build the crate, such as it's name, and a list of all dependencies
it needs to build. It also contains metadata neccessary for publishing it on [crates.io][],
Rust's crate registry, such as its version, list of authors, license, and description.
Finally, this file can also contain metadata for other tooling, some of which we will discuss
in this book. An example file might look like this:

```toml
[package]
name = "example-crate"
version = "0.1.0"
version = "MIT"
description = "My awesome crate"
authors = ["Max Mustermann <max@example.io>"]

[dependencies]
serde = { version = "1.0.12", features = ["derive"] }
anyhow = "1"
```

Dependencies can have optional features. This ensures a faster compilation, by only
compiling them when they are explicitly enabled. 

Cargo has built-in support for [semantic versioning][semver], so the versions
listed here are constraints. For example, when you specify version `1.0.12`, it really means
that your crate will work with any version `>=1.0.12` and `<1.1.0`, because semver considers
changes in the patch level (the third number) as non-breaking changes. 

This means that when you build your crate, Rust has to resolve the version
numbers. It stores those resolved version numbers in a separate file, `Cargo.lock`. This
is to ensure that you get reproducible builds: if two pepople build the project,
they always use exactly the same versions of dependencies. You have to manually tell
Cargo to go look if there are newer versions of dependencies that are within the constraints,
using `cargo update`. This and some issues around it will be covered in later chapters.

Here is an example of what this looks like:

```toml
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "serde"
version = "1.0.197"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2"
dependencies = [
 "serde_derive",
]

[[package]]
name = "anyhow"
version = "1.0.80"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ad32ce52e4161730f7098c077cd2ed6229b5804ccf99e5366be1ab72a98b4e1"
```

### Library and Binaries

Besides these two files, crates also contain Rust source code in various places.
We will list the default locations for these here, but the locations can be configured
and overridden in the metadata.

Every crate can define (at most) one library. The entrypoint for this is in `src/lib.rs`.
When you use a crate as a dependency, this is what other crates can see. Even if your
project is primarily an executable and not a library, you should try to put most of the code
into this library section, because this is what is visible to example code and integration
tests. I call this *library-first development*.

- articles for library-first development

Besides a single library, crates can also define binaries. These must contain a
`main()` function, and are compiled into executables. The default location for
binaries is `src/main.rs`, and it will produce an executable with the same name as
the crate. You can create additional ones under `src/bin/<name>.rs`, which will
create executables with the same name.

- graphic: executables linking against library

While Rust supports writing unit tests directly in the code, sometimes you want to
write tests from the perspective of an external user using your library (without
visibility into private functions). For this reason, you can write integration tests,
in `tests/<name>.rs`. These are compiled as if they were an external crate which links
to your crate, and as such only have access to the public API.

- graphic: tests linking against library

Finally, Rust has a large focus on making it easy to write documentation. In fact,
support for generating documentation is a built-in feature. In some cases, writing code
is the best kind of documentation. For this reason, Cargo has first-class support for keeping
code examples. If you put examples into `examples/<name>.rs`, they can be built and run by
cargo using `cargo build --examples` and `cargo run --example <name>`. There is even a
feature in Rust's built-in support for documentation, where it will pick up and reference
examples in the code documentation automatically.

- graphic: examples linking against library

See also: [Package Layout](https://doc.rust-lang.org/cargo/guide/project-layout.html).

## Creating a crate

You can use `cargo new` to create an empty crate. You have the choice of creating a library
crate (using the `--lib` switch) or a binary crate. Using `cargo` is recommended over
creating a new crate manually, because it will usually set useful defaults.

```
# create a binary-only crate
cargo new example-crate

# create a library crate
cargo new --lib example-crate
```

This is what an example crate layout looks like, after adding some dependencies. You can
see what the metadata and the source code looks like.

```files
path = "example-crate"
git_ignore = true
default_file = "Cargo.toml"
```

A more full-fledged example makes use of both the library and executables, has
some documentation strings, tests and examples in it, along with complete crate
metadata.


~~~admonish info
Cargo has some neat features besides being able to create new crates for you.
It can also manage dependencies for you. For example, if you are inside a crate
and you would like to add `serde` to the list of dependencies, you can use
`cargo add` to add it:

```
cargo add serde --features derive
```

This will edit your `Cargo.toml` to add the dependency, without touching
anything else.  Comments and formatting is preserved. The Cargo team is quite
good at looking how people use it and extending it with functionality that is
commonly requested.
~~~

## Crate Features

Rust crates can declare optional dependencies. These are additive, meaning that
enabling them should not break anything. The reason for this is that Rust performs
feature unification: if you have multiple dependendencies in your dependency that
depend on a single crate, it will only be built once with the features unified.

- dependency tree: feature unification

This is a good way to add additional, optional features to your crates while keeping
compilation times short for those who don't use them. If you have a dependency, you
can enable them by setting the `features` key:

```toml
[dependencies]
serde = { version = "1.0.182", features = ["derive"] }
```

For your own crates, you can declare optional features using the `features` section
in the metadata. Using features, you can enable optional dependencies, and inside your
code you can disable parts (functions, structs, modules) depending on them.

```toml
[features]
default = []
cool-feature = ["serde"]
```

```rust
#[cfg(feature = "cool-feature")]
fn only_visible_when_cool_feature_enabled() {
    // ...
}
```

## Crate Size


## Reading

[semver]: https://semver.org/
[crates.io]: https://crates.io/
